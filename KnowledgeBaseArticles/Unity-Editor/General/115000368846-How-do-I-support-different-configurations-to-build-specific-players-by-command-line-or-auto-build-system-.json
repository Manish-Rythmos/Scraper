[{"title":"How do I support different configurations to build specific players by command line or auto build system?","authorName":"Juan Diego Uran.","createdDate":"2017-01-17T17:35:44Z","updatedDate":"2017-05-08T09:04:54Z","labels":["iOS","Android","build"],"sections":[{"title":"Symptoms","content":["\n<li>I need to support different build settings for specific scenarios in my project (for example a build disabling the hardware statistics flag or removing custom analytics events), and call each of these configurations by command line or auto build system (for example Jenkins).</li>\n<li>I need to support automated builds of my game for iOS, Android, iOSTest, AndroidTest, WebGL or others, and call all of them by command line to integrate them with my build system.</li>\n"]},{"title":"Cause","content":["Unity builds different players but uses some similar global settings for all of them. For example, if the project uses Custom Defines by using <strong>PlayerSettings.SetScriptingDefineSymbolsForGroup</strong>, you may want to disable this feature for a particular test build but enable it for the production build. Unity doesn&#x2019;t support this feature by itself, so you must create different build scripts to support custom settings."]},{"title":"Resolution","content":["You can do this with Unity Cloud Build, which supports a lot of settings for getting multiple builds for different scenarios. For more information, see the <a href=\"https://docs.unity3d.com/Manual/UnityCloudBuild.html\">Unity Cloud Build documentation</a>.","Alternatively, you can create a method to make build validations, change settings and build different players. These methods have to be inside a script file located in an Editor folder, for example <strong>Assets/Editor/Builders/AndroidBuilder.cs</strong>. The class also doesn&#x2019;t need to extend any Unity class - the only requirement is that static functions are used.","For example, you want three different builders for Android, AndroidTest and iOS and use the command line (or auto build system) to create them automatically. As seen below, you can create two scripts: <strong>AndoidBuilder.cs (Assets/Editor/Builders/AndroidBuilder.cs)</strong> and <strong>iOSBuilder.cs (Assets/Editor/Builders/iOSBuilder.cs)</strong>:","<strong>AndroidBuilder.cs:</strong>","using UnityEditor;\n\nclass AndroidBuilder\n{\n    static void ProductionBuild()\n    {\n        // ... your code here, validations, flag changes, etc.\n\n        // Build the player.\\\n        BuildPlayerOptions buildPlayerOptions = new BuildPlayerOptions();\n        buildPlayerOptions.scenes = new[] { &quot;Assets/Scene1.unity&quot;, &quot;Assets/Scene2.unity&quot; };\n        buildPlayerOptions.locationPathName = &quot;AndroidProdBuild&quot;;\n        buildPlayerOptions.target = BuildTarget.Android;\n        buildPlayerOptions.options = BuildOptions.None;\n        BuildPipeline.BuildPlayer(buildPlayerOptions);\n    }\n\n    static void TestBuild ()\n    {\n        // ... your code here, validations, flag changes, etc.\n\n        // Build the player.\\\n        BuildPlayerOptions buildPlayerOptions = new BuildPlayerOptions();\n        buildPlayerOptions.scenes = new[] { &quot;Assets/SceneTest1.unity&quot;, &quot;Assets/SceneTest2.unity&quot; };\n        buildPlayerOptions.locationPathName = &quot;AndroidTestBuild&quot;;\n        buildPlayerOptions.target = BuildTarget.Android;\n        buildPlayerOptions.options = BuildOptions.None;\n        BuildPipeline.BuildPlayer(buildPlayerOptions);\n    }\n}\n","<strong>iOSBuilder.cs:</strong>","using UnityEditor;\n\nclass iOSBuilder\n{\n\n    static void ProductionBuild()\n    {\n        // ... your code here, validations, flag changes, etc.\n\n        // Build the player.\\\n        BuildPlayerOptions buildPlayerOptions = new BuildPlayerOptions();\n        buildPlayerOptions.scenes = new[] { &quot;Assets/Scene1.unity&quot;, &quot;Assets/Scene2.unity&quot; };\n        buildPlayerOptions.locationPathName = &quot;iOSProdBuild&quot;;\n        buildPlayerOptions.target = BuildTarget.iOS;\n        buildPlayerOptions.options = BuildOptions.None;\n        BuildPipeline.BuildPlayer(buildPlayerOptions);\n    }\n}\n","Then, you can call each builder function using these commands:","\n<li><em>/Path/To/Unity -quit -batchmode -executeMethod AndroidBuilder.ProductionBuild</em></li>\n<li><em>/Path/To/Unity -quit -batchmode -executeMethod AndroidBuilder.TestBuild</em></li>\n<li><em>/Path/To/Unity -quit -batchmode -executeMethod iOSBuilder.ProductionBuild</em></li>\n","Another approach is to have just one builder script and use arguments by command line to select which player should be built. You can find an example of what the script should look like below:","<strong>Builder.cs:</strong>","using UnityEditor;\nusing System;\n\nclass Builder\n{\n    static void iOSProductionBuild()\n    {\n        // ... your code here, validations, flag changes, etc.\n\n        // Build the player.\\\n        BuildPlayerOptions buildPlayerOptions = new BuildPlayerOptions();\n        buildPlayerOptions.scenes = new[] { &quot;Assets/Scene1.unity&quot;, &quot;Assets/Scene2.unity&quot; };\n        buildPlayerOptions.locationPathName = &quot;iOSProdBuild&quot;;\n        buildPlayerOptions.target = BuildTarget.iOS;\n        buildPlayerOptions.options = BuildOptions.None;\n        BuildPipeline.BuildPlayer(buildPlayerOptions);\n    }\n\n    static void AndroidProductionBuild()\n    {\n        // ... your code here, validations, flag changes, etc.\n\n        // Build the player.\\\n        BuildPlayerOptions buildPlayerOptions = new BuildPlayerOptions();\n        buildPlayerOptions.scenes = new[] { &quot;Assets/Scene1.unity&quot;, &quot;Assets/Scene2.unity&quot; };\n        buildPlayerOptions.locationPathName = &quot;AndroidProdBuild&quot;;\n        buildPlayerOptions.target = BuildTarget.Android;\n        buildPlayerOptions.options = BuildOptions.None;\n        BuildPipeline.BuildPlayer(buildPlayerOptions);\n    }\n\n    static void AndroidTestBuild()\n    {\n        // ... your code here, validations, flag changes, etc.\n\n        // Build the player.\\\n        BuildPlayerOptions buildPlayerOptions = new BuildPlayerOptions();\n        buildPlayerOptions.scenes = new[] { &quot;Assets/SceneTest1.unity&quot;, &quot;Assets/SceneTest2.unity&quot; };\n        buildPlayerOptions.locationPathName = &quot;AndroidTestBuild&quot;;\n        buildPlayerOptions.target = BuildTarget.Android;\n        buildPlayerOptions.options = BuildOptions.None;\n        BuildPipeline.BuildPlayer(buildPlayerOptions);\n    }\n\n\n    static void Build ()\n    {\n        string[] arguments = Environment.GetCommandLineArgs();\n        switch ( arguments[1] )\n        {\n            case &quot;Android&quot;:\n                AndroidProductionBuild();\n                break;\n            case &quot;AndroidTest&quot;:\n                AndroidTestBuild();\n                break;\n            case &quot;iOS&quot;:\n                iOSProductionBuild();\n                break;\n            default:\n                AndroidProductionBuild();\n                break;\n        }\n    }\n}\n","You can then call the builder function using these commands:","\n<li><em>/Path/To/Unity -quit -batchmode -executeMethod Builder.Build Android</em></li>\n<li><em>/Path/To/Unity -quit -batchmode -executeMethod Builder.Build AndroidTest</em></li>\n<li><em>/Path/To/Unity -quit -batchmode -executeMethod Builder.Build iOS</em></li>\n","You can extend this approach by using additional arguments (such as <strong>-target=Android|iOS -env=prod|dev</strong>) and custom arguments if needed.","You can combine these ideas with your auto build system to automatically create different players for different requirements and avoid human error when building.","This is a short list of customizations you can get with this approach:","\n<li>A development build for different scenarios.</li>\n<li>Custom scripting #define directives by using PlayerSettings.SetScriptingDefineSymbolsForGroup.</li>\n<li>Include/exclude plugins.</li>\n<li>Include/exclude specific Scenes.</li>\n<li>Edit any Asset file located in MyProject/ProjectSettings/*.asset (for example AudioManager.asset, GraphicsSettings.asset, and ProjectSettings.asset).</li>\n<li>Update resources using C# scripts.</li>\n<li>Turn your custom plugins on or off according to your project&#x2019;s needs (for example by platform, by rendering API, or by any other particular feature).</li>\n<li>Use any C# script if needed.</li>\n"]},{"title":"More Information","content":["For more information, consult the following documentation:","\n<li><a href=\"https://docs.unity3d.com/Manual/CommandLineArguments.html\">Command line arguments documentation</a>&#xA0;</li>\n<li><a href=\"https://docs.unity3d.com/ScriptReference/BuildPipeline.BuildPlayer.html\">BuildPipeline.BuildPlayer script reference documentation</a></li>\n<li><a href=\"https://msdn.microsoft.com/es-es/library/system.environment.getcommandlineargs(v=vs.110).aspx\">Microsoft M&#xE9;todo Environment.GetCommandLineArgs () documentation</a></li>\n<li><a href=\"https://docs.unity3d.com/Manual/UnityCloudBuildCustomScriptingDefineDirectives.html\">Custom scripting #define directives documentation</a></li>\n"]}]}]